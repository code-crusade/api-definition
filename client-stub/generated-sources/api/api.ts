/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:8080".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Type encompassing any value type
 * @export
 * @interface AnyValue
 */
export interface AnyValue {
}

/**
 * 
 * @export
 * @interface CodeValidationReport
 */
export interface CodeValidationReport {
    /**
     * 
     * @type {number}
     * @memberof CodeValidationReport
     */
    exerciseId?: number;
    /**
     * 
     * @type {Array<CodeValidationReportResults>}
     * @memberof CodeValidationReport
     */
    results?: Array<CodeValidationReportResults>;
}

/**
 * 
 * @export
 * @interface CodeValidationReportResults
 */
export interface CodeValidationReportResults {
    /**
     * 
     * @type {string}
     * @memberof CodeValidationReportResults
     */
    testName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CodeValidationReportResults
     */
    passed?: boolean;
    /**
     * 
     * @type {Array<any>}
     * @memberof CodeValidationReportResults
     */
    inputParameters?: Array<any>;
    /**
     * 
     * @type {any}
     * @memberof CodeValidationReportResults
     */
    expectedOutput?: any;
    /**
     * 
     * @type {any}
     * @memberof CodeValidationReportResults
     */
    actualOutput?: any;
}

/**
 * Exercise difficulty range
 * @export
 * @enum {string}
 */
export enum Difficulties {
    EASY = 'EASY',
    MEDIUM = 'MEDIUM',
    HARD = 'HARD'
}

/**
 * 
 * @export
 * @interface Exercise
 */
export interface Exercise {
    /**
     * 
     * @type {number}
     * @memberof Exercise
     */
    id?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Exercise
     */
    title?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Exercise
     */
    description?: { [key: string]: string; };
    /**
     * 
     * @type {Difficulties}
     * @memberof Exercise
     */
    difficulty?: Difficulties;
    /**
     * 
     * @type {Template}
     * @memberof Exercise
     */
    entryPoint?: Template;
    /**
     * 
     * @type {Array<string>}
     * @memberof Exercise
     */
    supportedLanguages?: Array<string>;
    /**
     * 
     * @type {Array<UnitTest>}
     * @memberof Exercise
     */
    unitTests?: Array<UnitTest>;
    /**
     * 
     * @type {Template}
     * @memberof Exercise
     */
    template?: Template;
}

/**
 * 
 * @export
 * @interface ExerciseSubmission
 */
export interface ExerciseSubmission {
    /**
     * 
     * @type {number}
     * @memberof ExerciseSubmission
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ExerciseSubmission
     */
    exerciseId?: number;
    /**
     * 
     * @type {number}
     * @memberof ExerciseSubmission
     */
    userId?: number;
    /**
     * 
     * @type {string}
     * @memberof ExerciseSubmission
     */
    code?: string;
    /**
     * 
     * @type {any}
     * @memberof ExerciseSubmission
     */
    language?: any;
    /**
     * 
     * @type {Date}
     * @memberof ExerciseSubmission
     */
    createdAt?: Date;
}

/**
 * Group of students
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    groupNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    _class?: string;
    /**
     * 
     * @type {Semesters}
     * @memberof Group
     */
    semester?: Semesters;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    year?: number;
    /**
     * 
     * @type {Array<Student>}
     * @memberof Group
     */
    students?: Array<Student>;
}

/**
 * 
 * @export
 * @interface RFC7807Body
 */
export interface RFC7807Body {
    /**
     * 
     * @type {string}
     * @memberof RFC7807Body
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof RFC7807Body
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof RFC7807Body
     */
    detail?: string;
    /**
     * 
     * @type {number}
     * @memberof RFC7807Body
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof RFC7807Body
     */
    instance?: string;
}

/**
 * 
 * @export
 * @interface RunnerArguments
 */
export interface RunnerArguments {
    /**
     * code
     * @type {string}
     * @memberof RunnerArguments
     */
    code?: string;
    /**
     * language
     * @type {string}
     * @memberof RunnerArguments
     */
    language?: string;
}

/**
 * Semester values.
 * @export
 * @enum {string}
 */
export enum Semesters {
    FALL = 'FALL',
    WINTER = 'WINTER',
    SUMMER = 'SUMMER'
}

/**
 * A student user
 * @export
 * @interface Student
 */
export interface Student extends User {
    /**
     * 
     * @type {string}
     * @memberof Student
     */
    accessCode?: string;
}

/**
 * Languages supported by the api
 * @export
 * @enum {string}
 */
export enum SupportedLanguages {
    Cpp = 'Cpp',
    Java = 'Java',
    Javascript = 'Javascript',
    Python = 'Python'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SupportedType {
    BOOLEAN = 'BOOLEAN',
    INT = 'INT',
    FLOAT = 'FLOAT',
    STRING = 'STRING',
    BOOLEANARR = 'BOOLEAN_ARR',
    INTARR = 'INT_ARR',
    FLOATARR = 'FLOAT_ARR',
    STRINGARR = 'STRING_ARR'
}

/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    className?: string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    functionName?: string;
    /**
     * 
     * @type {Array<TemplateArgs>}
     * @memberof Template
     */
    args?: Array<TemplateArgs>;
    /**
     * Type encompassing any value type
     * @type {any}
     * @memberof Template
     */
    functionReturnValue?: any;
    /**
     * 
     * @type {SupportedType}
     * @memberof Template
     */
    functionReturnType?: SupportedType;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Template
     */
    prependedCode?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Template
     */
    appendedCode?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface TemplateArgs
 */
export interface TemplateArgs {
    /**
     * 
     * @type {string}
     * @memberof TemplateArgs
     */
    name?: string;
    /**
     * 
     * @type {SupportedType}
     * @memberof TemplateArgs
     */
    type?: SupportedType;
}

/**
 * A test input and its type
 * @export
 * @interface TestInput
 */
export interface TestInput {
    /**
     * 
     * @type {SupportedType}
     * @memberof TestInput
     */
    inputType?: SupportedType;
    /**
     * Type encompassing any value type
     * @type {any}
     * @memberof TestInput
     */
    inputValue?: any;
}

/**
 * A simple input-ouput unit test
 * @export
 * @interface UnitTest
 */
export interface UnitTest {
    /**
     * 
     * @type {number}
     * @memberof UnitTest
     */
    id?: number;
    /**
     * 
     * @type {Array<TestInput>}
     * @memberof UnitTest
     */
    input?: Array<TestInput>;
    /**
     * Type encompassing any value type
     * @type {any}
     * @memberof UnitTest
     */
    outputValue?: any;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface UserPass
 */
export interface UserPass {
    /**
     * 
     * @type {string}
     * @memberof UserPass
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPass
     */
    password?: string;
}


/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Provides a session cookie given a valid CAS Service ticket
         * @param {string} ticket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCasloginGet(ticket: string, options: any = {}): FetchArgs {
            // verify required parameter 'ticket' is not null or undefined
            if (ticket === null || ticket === undefined) {
                throw new RequiredError('ticket','Required parameter ticket was null or undefined when calling authCasloginGet.');
            }
            const localVarPath = `/auth/caslogin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ticket !== undefined) {
                localVarQueryParameter['ticket'] = ticket;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Provides a session cookie given a username and password
         * @param {UserPass} userPass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(userPass: UserPass, options: any = {}): FetchArgs {
            // verify required parameter 'userPass' is not null or undefined
            if (userPass === null || userPass === undefined) {
                throw new RequiredError('userPass','Required parameter userPass was null or undefined when calling authLoginPost.');
            }
            const localVarPath = `/auth/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserPass" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(userPass || {}) : (userPass || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Provides a session cookie given a valid CAS Service ticket
         * @param {string} ticket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCasloginGet(ticket: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authCasloginGet(ticket, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Provides a session cookie given a username and password
         * @param {UserPass} userPass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(userPass: UserPass, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).authLoginPost(userPass, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Provides a session cookie given a valid CAS Service ticket
         * @param {string} ticket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCasloginGet(ticket: string, options?: any) {
            return AuthApiFp(configuration).authCasloginGet(ticket, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Provides a session cookie given a username and password
         * @param {UserPass} userPass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(userPass: UserPass, options?: any) {
            return AuthApiFp(configuration).authLoginPost(userPass, options)(fetch, basePath);
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * 
     * @summary Provides a session cookie given a valid CAS Service ticket
     * @param {string} ticket 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authCasloginGet(ticket: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary Provides a session cookie given a username and password
     * @param {UserPass} userPass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    authLoginPost(userPass: UserPass, options?: any): Promise<{}>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * 
     * @summary Provides a session cookie given a valid CAS Service ticket
     * @param {string} ticket 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCasloginGet(ticket: string, options?: any) {
        return AuthApiFp(this.configuration).authCasloginGet(ticket, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Provides a session cookie given a username and password
     * @param {UserPass} userPass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(userPass: UserPass, options?: any) {
        return AuthApiFp(this.configuration).authLoginPost(userPass, options)(this.fetch, this.basePath);
    }

}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the specified exercise
         * @param {number} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdGet(exerciseId: number, options: any = {}): FetchArgs {
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling exercisesExerciseIdGet.');
            }
            const localVarPath = `/exercises/{exerciseId}`
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the list of submissions for the specified exercise
         * @param {number} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsGet(exerciseId: number, options: any = {}): FetchArgs {
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling exercisesExerciseIdSubmissionsGet.');
            }
            const localVarPath = `/exercises/{exerciseId}/submissions`
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submits the code as the current user's solution for the exercise
         * @param {number} exerciseId 
         * @param {RunnerArguments} runnerArguments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsPost(exerciseId: number, runnerArguments: RunnerArguments, options: any = {}): FetchArgs {
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling exercisesExerciseIdSubmissionsPost.');
            }
            // verify required parameter 'runnerArguments' is not null or undefined
            if (runnerArguments === null || runnerArguments === undefined) {
                throw new RequiredError('runnerArguments','Required parameter runnerArguments was null or undefined when calling exercisesExerciseIdSubmissionsPost.');
            }
            const localVarPath = `/exercises/{exerciseId}/submissions`
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RunnerArguments" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(runnerArguments || {}) : (runnerArguments || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the list of submissions for the specified exercise
         * @param {number} exerciseId 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsSubmissionIdGet(exerciseId: number, submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling exercisesExerciseIdSubmissionsSubmissionIdGet.');
            }
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling exercisesExerciseIdSubmissionsSubmissionIdGet.');
            }
            const localVarPath = `/exercises/{exerciseId}/submissions/{submissionId}`
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)))
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the results of the exercise validation for this submission
         * @param {number} exerciseId 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsSubmissionIdResultsGet(exerciseId: number, submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling exercisesExerciseIdSubmissionsSubmissionIdResultsGet.');
            }
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling exercisesExerciseIdSubmissionsSubmissionIdResultsGet.');
            }
            const localVarPath = `/exercises/{exerciseId}/submissions/{submissionId}/results`
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)))
                .replace(`{${"submissionId"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate the code against the exercise's test suite
         * @param {number} exerciseId 
         * @param {RunnerArguments} runnerArguments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdTestPost(exerciseId: number, runnerArguments: RunnerArguments, options: any = {}): FetchArgs {
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling exercisesExerciseIdTestPost.');
            }
            // verify required parameter 'runnerArguments' is not null or undefined
            if (runnerArguments === null || runnerArguments === undefined) {
                throw new RequiredError('runnerArguments','Required parameter runnerArguments was null or undefined when calling exercisesExerciseIdTestPost.');
            }
            const localVarPath = `/exercises/{exerciseId}/test`
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RunnerArguments" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(runnerArguments || {}) : (runnerArguments || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the full list of exercises
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesIndex(options: any = {}): FetchArgs {
            const localVarPath = `/exercises`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication authCookie required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Runs provided code
         * @param {number} exerciseId 
         * @param {RunnerArguments} runnerArguments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCodeForExercise(exerciseId: number, runnerArguments: RunnerArguments, options: any = {}): FetchArgs {
            // verify required parameter 'exerciseId' is not null or undefined
            if (exerciseId === null || exerciseId === undefined) {
                throw new RequiredError('exerciseId','Required parameter exerciseId was null or undefined when calling runCodeForExercise.');
            }
            // verify required parameter 'runnerArguments' is not null or undefined
            if (runnerArguments === null || runnerArguments === undefined) {
                throw new RequiredError('runnerArguments','Required parameter runnerArguments was null or undefined when calling runCodeForExercise.');
            }
            const localVarPath = `/runner/{exerciseId}`
                .replace(`{${"exerciseId"}}`, encodeURIComponent(String(exerciseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RunnerArguments" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(runnerArguments || {}) : (runnerArguments || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the specified exercise
         * @param {number} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdGet(exerciseId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Exercise> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exercisesExerciseIdGet(exerciseId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the list of submissions for the specified exercise
         * @param {number} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsGet(exerciseId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ExerciseSubmission>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exercisesExerciseIdSubmissionsGet(exerciseId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Submits the code as the current user's solution for the exercise
         * @param {number} exerciseId 
         * @param {RunnerArguments} runnerArguments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsPost(exerciseId: number, runnerArguments: RunnerArguments, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exercisesExerciseIdSubmissionsPost(exerciseId, runnerArguments, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the list of submissions for the specified exercise
         * @param {number} exerciseId 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsSubmissionIdGet(exerciseId: number, submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExerciseSubmission> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exercisesExerciseIdSubmissionsSubmissionIdGet(exerciseId, submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the results of the exercise validation for this submission
         * @param {number} exerciseId 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsSubmissionIdResultsGet(exerciseId: number, submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CodeValidationReport> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exercisesExerciseIdSubmissionsSubmissionIdResultsGet(exerciseId, submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Validate the code against the exercise's test suite
         * @param {number} exerciseId 
         * @param {RunnerArguments} runnerArguments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdTestPost(exerciseId: number, runnerArguments: RunnerArguments, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CodeValidationReport> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exercisesExerciseIdTestPost(exerciseId, runnerArguments, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the full list of exercises
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesIndex(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Exercise>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).exercisesIndex(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Runs provided code
         * @param {number} exerciseId 
         * @param {RunnerArguments} runnerArguments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCodeForExercise(exerciseId: number, runnerArguments: RunnerArguments, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).runCodeForExercise(exerciseId, runnerArguments, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Gets the specified exercise
         * @param {number} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdGet(exerciseId: number, options?: any) {
            return DefaultApiFp(configuration).exercisesExerciseIdGet(exerciseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the list of submissions for the specified exercise
         * @param {number} exerciseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsGet(exerciseId: number, options?: any) {
            return DefaultApiFp(configuration).exercisesExerciseIdSubmissionsGet(exerciseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Submits the code as the current user's solution for the exercise
         * @param {number} exerciseId 
         * @param {RunnerArguments} runnerArguments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsPost(exerciseId: number, runnerArguments: RunnerArguments, options?: any) {
            return DefaultApiFp(configuration).exercisesExerciseIdSubmissionsPost(exerciseId, runnerArguments, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the list of submissions for the specified exercise
         * @param {number} exerciseId 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsSubmissionIdGet(exerciseId: number, submissionId: number, options?: any) {
            return DefaultApiFp(configuration).exercisesExerciseIdSubmissionsSubmissionIdGet(exerciseId, submissionId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the results of the exercise validation for this submission
         * @param {number} exerciseId 
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdSubmissionsSubmissionIdResultsGet(exerciseId: number, submissionId: number, options?: any) {
            return DefaultApiFp(configuration).exercisesExerciseIdSubmissionsSubmissionIdResultsGet(exerciseId, submissionId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Validate the code against the exercise's test suite
         * @param {number} exerciseId 
         * @param {RunnerArguments} runnerArguments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesExerciseIdTestPost(exerciseId: number, runnerArguments: RunnerArguments, options?: any) {
            return DefaultApiFp(configuration).exercisesExerciseIdTestPost(exerciseId, runnerArguments, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the full list of exercises
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exercisesIndex(options?: any) {
            return DefaultApiFp(configuration).exercisesIndex(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Runs provided code
         * @param {number} exerciseId 
         * @param {RunnerArguments} runnerArguments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runCodeForExercise(exerciseId: number, runnerArguments: RunnerArguments, options?: any) {
            return DefaultApiFp(configuration).runCodeForExercise(exerciseId, runnerArguments, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * 
     * @summary Gets the specified exercise
     * @param {number} exerciseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    exercisesExerciseIdGet(exerciseId: number, options?: any): Promise<Exercise>;

    /**
     * 
     * @summary Gets the list of submissions for the specified exercise
     * @param {number} exerciseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    exercisesExerciseIdSubmissionsGet(exerciseId: number, options?: any): Promise<Array<ExerciseSubmission>>;

    /**
     * 
     * @summary Submits the code as the current user's solution for the exercise
     * @param {number} exerciseId 
     * @param {RunnerArguments} runnerArguments 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    exercisesExerciseIdSubmissionsPost(exerciseId: number, runnerArguments: RunnerArguments, options?: any): Promise<{}>;

    /**
     * 
     * @summary Gets the list of submissions for the specified exercise
     * @param {number} exerciseId 
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    exercisesExerciseIdSubmissionsSubmissionIdGet(exerciseId: number, submissionId: number, options?: any): Promise<ExerciseSubmission>;

    /**
     * 
     * @summary Gets the results of the exercise validation for this submission
     * @param {number} exerciseId 
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    exercisesExerciseIdSubmissionsSubmissionIdResultsGet(exerciseId: number, submissionId: number, options?: any): Promise<CodeValidationReport>;

    /**
     * 
     * @summary Validate the code against the exercise's test suite
     * @param {number} exerciseId 
     * @param {RunnerArguments} runnerArguments 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    exercisesExerciseIdTestPost(exerciseId: number, runnerArguments: RunnerArguments, options?: any): Promise<CodeValidationReport>;

    /**
     * 
     * @summary Gets the full list of exercises
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    exercisesIndex(options?: any): Promise<Array<Exercise>>;

    /**
     * 
     * @summary Runs provided code
     * @param {number} exerciseId 
     * @param {RunnerArguments} runnerArguments 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    runCodeForExercise(exerciseId: number, runnerArguments: RunnerArguments, options?: any): Promise<{}>;

}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * 
     * @summary Gets the specified exercise
     * @param {number} exerciseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exercisesExerciseIdGet(exerciseId: number, options?: any) {
        return DefaultApiFp(this.configuration).exercisesExerciseIdGet(exerciseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the list of submissions for the specified exercise
     * @param {number} exerciseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exercisesExerciseIdSubmissionsGet(exerciseId: number, options?: any) {
        return DefaultApiFp(this.configuration).exercisesExerciseIdSubmissionsGet(exerciseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Submits the code as the current user's solution for the exercise
     * @param {number} exerciseId 
     * @param {RunnerArguments} runnerArguments 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exercisesExerciseIdSubmissionsPost(exerciseId: number, runnerArguments: RunnerArguments, options?: any) {
        return DefaultApiFp(this.configuration).exercisesExerciseIdSubmissionsPost(exerciseId, runnerArguments, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the list of submissions for the specified exercise
     * @param {number} exerciseId 
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exercisesExerciseIdSubmissionsSubmissionIdGet(exerciseId: number, submissionId: number, options?: any) {
        return DefaultApiFp(this.configuration).exercisesExerciseIdSubmissionsSubmissionIdGet(exerciseId, submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the results of the exercise validation for this submission
     * @param {number} exerciseId 
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exercisesExerciseIdSubmissionsSubmissionIdResultsGet(exerciseId: number, submissionId: number, options?: any) {
        return DefaultApiFp(this.configuration).exercisesExerciseIdSubmissionsSubmissionIdResultsGet(exerciseId, submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Validate the code against the exercise's test suite
     * @param {number} exerciseId 
     * @param {RunnerArguments} runnerArguments 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exercisesExerciseIdTestPost(exerciseId: number, runnerArguments: RunnerArguments, options?: any) {
        return DefaultApiFp(this.configuration).exercisesExerciseIdTestPost(exerciseId, runnerArguments, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the full list of exercises
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public exercisesIndex(options?: any) {
        return DefaultApiFp(this.configuration).exercisesIndex(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Runs provided code
     * @param {number} exerciseId 
     * @param {RunnerArguments} runnerArguments 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public runCodeForExercise(exerciseId: number, runnerArguments: RunnerArguments, options?: any) {
        return DefaultApiFp(this.configuration).runCodeForExercise(exerciseId, runnerArguments, options)(this.fetch, this.basePath);
    }

}

